#pragma once
#include <vector>
#include <string>
using namespace std;

namespace {
	//Препроцессим паттерн для получения таблицы длин сабпаттернов
	//результат возвращаем в векторе интов

	vector<unsigned> KMPProcessPattern(const string& pattern) {
		vector<unsigned> result(pattern.size());

		//Паттерн может содержать сабпаттерны - последовательность символов, которые встречаются в паттерне
		//более одного раза ("ABAB" состоит из сабпаттернов "A", "B" и "АB")
		//Нас интересуют те сабпаттерны, которые совпадают с началом основного паттерна
		//(в "ABCFEFEAB" нас интересуют только сабпаттерны "A" и "AB", т.к. они соответсуют началу паттерна)

		//Пример: P = "ABCABAABC"
		//        можно визуально разделить на повторы - ABC AB A ABC
		//        0) первая часть ABC не считается повтором или сабпаттерном, т.к. начинается с индекса 0
		//        1) P[4]=A и P[5]=B формируют сабпаттерн AB, который совпадает с P[0]=A, P[1]=B, таким образом длина сабпаттерна = 2 
		//        2) P[6]=A сабпаттерн с длиной 1
		//        3) P[7]=A, P[8]=B, P[9]=C сабпаттерн с длиной 3

		int a = 0;
		for (unsigned i = 1; i < pattern.size(); ++i)//просматриваем по одному все символы, кроме первого, т.к. первый символ равен самому себе.
		{
			//Суть: итерируемся до тех пор пока текущий элемент итерации pattern[i] не будет равен первому символу паттерна
			//то есть пока не выполнится pattern[i] == pattern[0]
			//если это произошло значит у нас появился сабпаттерн, который надо исследовать в следующих итерациях, как минимум его длина уже 
			//1 т.к. кол-во совпадений на данный момент = 1. В следующей итерации нам надо сравнить элемент следующий за pattern[i] с элементом 
			//следующим за pattern[0] то есть pattern[i+1] == pattern[0+1] и каждый раз при прохождении условия равенства прибавлять в сабпаттерн
			//pattern[i+1] мы получаем на-халяву т.к. в for-loop у нас есть выражение ++i
			//а вот pattern[0+1] нам надо получать каждый раз самим. Для этого введена переменная int a = 0; Действительно до первого сабпаттерна 
			//a = 0 , pattern[a] = pattern[0]. Как только pattern[i] == pattern[a] верно , мы инкрементируем а (a=a+1) чтобы в следущей итерации
			//проверять следующие елементы. 


			//Пример: pattern = "ABCВABСDD"
			//a=0;i=1; pattern[a] = A; pattern[i] = B; несовпадение				result[i]=0 
			//a=0;i=2; pattern[a] = A; pattern[i] = С; несовпадение				result[i]=0
			//a=0;i=3; pattern[a] = A; pattern[i] = B; несовпадение				result[i]=0
			//a=0;i=4; pattern[a] = A; pattern[i] = A; совпадение. a=a+1=1		result[i]=1
			//a=1;i=5; pattern[a] = B; pattern[i] = B; coвпадение. a=a+1=2		result[i]=2
			//a=2;i=6; pattern[a] = C; pattern[i] = C; coвпадение. a=a+1=3		result[i]=3

			if (pattern[a] == pattern[i]) ++a;

			//Допустим в прошлой итерации(-иях) уже был найден и подсчитан сабпаттерн но в этой
			//итерации у нас несовпадение. Возможно что на данном шаге начинается новый сабпаттерн
			//Это необходимо проверить. Если pattern[i] == pattern[0], то в следующей итерации надо будет опять 
			//проверять последующие совпадения, если нет, то обнуляем a и дальнейшие символы будут сравниваться с
			//нулевым до следующего сабпаттерна


			else if (a > 0) //данная проверка актуальна только для случаев когда мы только что завершили подсчет
							//длины сабпаттерна и а не равно 0
			{
				if (pattern[i] == pattern[0]) {
					a = 1;
				}
				else
				{
					a = 0;
				}
			}

			//в конце каждой итерации переменная "а" представляет собой закончый результат функции для каждого
			//текущего символа паттерна
			//Пример: pattern = "ABCBABCDD"
			//		  result  = "000012300"

			//Пример: pattern = "ABCBABCBD"
			//		  result  = "000012340"

			//Пример: pattern = "ABCBABCBA"
			//		  result  = "000012341"

			//Пример: pattern = "AACBABCBD"
			//		  result  = "010010000"

			//Пример: pattern = "AACBAACAD"
			//		  result  = "010012010"

			result[i] = a;
		}
		return result;
	}

	//Основной цикл алгоритма с использованием таблицы длин сабпаттернов
	vector<unsigned> KMPMainSearchLoop(const string& buffer, const string& pattern, const vector<unsigned> pattern_subdata) {
		vector<unsigned> result;
		unsigned patternLength = pattern.length();
		unsigned bufferLength = buffer.length();
		unsigned searchLimit = bufferLength - patternLength + 1;


		//В данном цикле мы шаг за шагом проверяем каждый символ на совпадение с нулевым символом паттерна
		//Как только buffer[i] == pattern[0] вернО, мы запускаем еще один цикл на совпадение всех последующих элементов
		//паттерна buffer[i+1] == pattern[0+1], buffer[i+2] == pattern[0+2], ..., buffer[i+n] == pattern[n]
		//в какой то мемент цикл заканчивается либо по причине несовпадения, либо по причине полного совпадения всего 
		//паттерна. Алгоритм должен решить, какой индекс "i" проверять следующим.
		//Суть Knuth-Morris-Pratt алгоритма заключается именно в этом решении.
		//
		unsigned j = 0;
		for (unsigned i = 0; i < searchLimit;) {
			//Если есть совпадение с нулевым символом, пробегаемся по всему паттерну и проверяем по-символьно на равенство
			//"j" служит счетчиком совпадений, инициализируем его единицей , тк. сравнение с нулевым символом уже было
			for (; j < patternLength; ++j)
			{
				//преждевременный выход из цикла в случае если было неравентсво
				//"j" будет указывать на номер первого "неравного" элемента паттерна, 
				if (buffer[i + j] != pattern[j])
					break;
			}

			//в случае несовпадения нулевого элемента, повторяем цикл с простым сдвигом "i" + 1 
			if (j == 0)
			{
				++i;
				continue;
			}

			//если цикл закончился полным перебором елементов паттерна, j равен кол-ву символов в паттерне
			//и мы нашли полное совпадение в паттерне, которое запишем в результат
			if (j == patternLength)
			{
				result.push_back(i);
			}

			//алгоритму надо решить на какое число символов нужно увеличить "i" перед следующей итерацией
			//текущий индекс "i" указывает на элемент который совпадает с нулевым элементом паттерна
			//мы так же знаем сколько элементов совпало с паттерном после индекса i
			//Вот индексы нашего буффера: 0,1,2,3,4,5,...    i,i+1,i+2,i+...,i+j,    ....
			//мы знаем что все элементы в буффере от i до i+(j-1) совпадают с нашим паттерном. (jй элемент указывает на несовпадение, последнее совпадение было на j-1)
			//значит от i до i+j-1 в буффере появляются те же сабпаттерны что и от 0 до j-1 в нашем паттерне
			//раз так, мы можем их пропустить. В таблице сабпаттернов под индексом j-1 указано сколько элементов на данный момент 
			//один за другим совпало с начальными символами паттерна,
			//то есть сколько элементов мы уже прошли, не получив несовпадения
			//допустим мы ищем паттерн "cocacola" в буфере "...сocacoca..."
			//6 элементов совпали "cocaco" и на 7м элементе произошло несовпадение "c"!="l"
			//но в паттерне "cocacola" есть субпаттерны, по таблице, полученной в прошлой фазе "00101200", их можно вычислить
			//3й элемент таблицы равен 1 и совпадает с 3м элементом паттерна = "c"
			//5й элемент равен 1 и совпадает с 5м элементом паттерна = "c"
			//6й элемент равен 2м и означает что это второй по счету совпадающий элемент, и вместе с первым формирует
			//сабпаттерн "co" .выходит на момент останова по несовпадению мы прошли подряд 2 символа , которые являются началом паттерна.
			//С этих двух символов нам и следует начать следующий цикл сравнения. 

			//shift равен кол-ву символов , которые мы пропускаем, эта цифра совпадает с таблчным значением сабпаттернов под элементом последнео
			//совпадения (j-1)
			int shift = pattern_subdata[j - 1];

			//сдвигаем i на это число
			i += j - shift;

			//"j" тоже "пропускает" эти несколько элементов, то есть следующую проверку начинаем уже не с нулевого элемента
			j = shift;
		}
		return result;
	}
}

vector<unsigned> KMPStringSearch(const string& buffer, const string& pattern) {
	auto pattern_subdata = KMPProcessPattern(pattern);
	auto result = KMPMainSearchLoop(buffer, pattern, pattern_subdata);
	return result;
}